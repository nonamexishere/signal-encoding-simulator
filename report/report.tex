\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{titlesec}

% Page geometry
\geometry{margin=2.5cm}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\rhead{BLG 337E - Signal Encoding \& Modulation}
\lhead{ITU}
\rfoot{Page \thepage}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{orange},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=5pt
}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\begin{document}

\begin{titlepage} % Kapak sayfası için özel ortam
\centering

% Sayfa başı ile başlık arası boşluk
\vspace*{1cm}

% Logo Alanı (Opsiyonel: logo dosyan varsa ekle yoksa boş bırakır)
\includegraphics[width=0.3\textwidth]{itu_logo.jpg}\\[1cm]

{\huge \textbf{Signal Encoding and Modulation Techniques} \par}
\vspace{0.5cm}
{\large Technical Report - BLG 337E Principles of Computer Communication \par}

\vfill % Dikey boşluğu doldurur (içeriği aşağı iter)

{\large \textbf{Authors:}\par}
\vspace{0.3cm} % Başlık ile isimler arasında hafif bir boşluk
{\large Mustafa Bozdoğan 150210007 \par}
{\large Enes Saçak 150210014 \par}

\vfill

% Ödev dökümanındaki hoca ve asistan bilgilerini eklemek boşluğu profesyonelce doldurur
{\small \textbf{Instructor:}\par}
{\small Prof. Dr. Abdül Halim Zaim \par}
\vspace{0.3cm}
{\small \textbf{Teaching Assistants:}\par}
{\small Gülizar Kondel \quad Büşra Bayram \par}

\vfill

{\large January 2026 \par}
{\large Istanbul Technical University \par}

\vfill

\begin{abstract}
This report presents a comprehensive simulation and analysis of data transmission between two computers using encoding, modulation, and demodulation techniques. The implementation covers four fundamental transmission modes: Digital-to-Digital line coding, Digital-to-Analog modulation, Analog-to-Digital conversion, and Analog-to-Analog modulation. We implement 16 different algorithms based on William Stallings' ``Data and Computer Communications'' curriculum, develop an interactive web-based simulator using Streamlit, and perform AI-assisted optimization with detailed benchmarking analysis.
\end{abstract}
\vspace*{1cm} % Sayfa sonu boşluğu
\end{titlepage}

\newpage
\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

Data communication between computers requires the conversion of data into signals suitable for transmission over various media. This report presents the implementation of a signal encoding and modulation simulator that demonstrates four fundamental transmission modes:

\begin{enumerate}
    \item \textbf{Digital-to-Digital (Line Coding)}: Converting digital data to digital signals
    \item \textbf{Digital-to-Analog (Modulation)}: Converting digital data to analog signals
    \item \textbf{Analog-to-Digital (Digitization)}: Converting analog signals to digital data
    \item \textbf{Analog-to-Analog (Modulation)}: Converting analog signals to different analog signals
\end{enumerate}

The simulator implements algorithms as defined in William Stallings' textbook and provides an interactive interface for visualizing the encoding/modulation processes.

%==============================================================================
\section{Theoretical Background}
%==============================================================================

\subsection{Digital-to-Digital Encoding (Line Coding)}

Line coding converts digital data into digital signals suitable for transmission over a physical medium. The main objectives are synchronization, error detection, and spectral efficiency.

\subsubsection{NRZ (Non-Return to Zero)}

\textbf{NRZ-L (Level):} The signal level directly represents the bit value.
\begin{itemize}
    \item Binary 0 $\rightarrow$ Positive voltage (+V)
    \item Binary 1 $\rightarrow$ Negative voltage (-V)
\end{itemize}

\textbf{NRZI (Invert on ones):} Uses signal transitions to represent data.
\begin{itemize}
    \item Binary 1 $\rightarrow$ Transition at the beginning of the bit period
    \item Binary 0 $\rightarrow$ No transition
\end{itemize}

\textbf{Advantages:} Simple implementation, efficient bandwidth usage.\\
\textbf{Disadvantages:} No self-clocking capability, DC component issues with long sequences of same bits.

\subsubsection{Bipolar-AMI (Alternate Mark Inversion)}

A three-level encoding scheme:
\begin{itemize}
    \item Binary 0 $\rightarrow$ Zero voltage (no signal)
    \item Binary 1 $\rightarrow$ Alternating positive and negative voltage
\end{itemize}

The alternating polarity for 1s eliminates the DC component and provides error detection capability. However, long sequences of zeros cause synchronization loss.

\subsubsection{Manchester Encoding (IEEE 802.3)}

Self-clocking code with guaranteed mid-bit transitions:
\begin{itemize}
    \item Binary 0 $\rightarrow$ High-to-low transition at mid-bit
    \item Binary 1 $\rightarrow$ Low-to-high transition at mid-bit
\end{itemize}

\textbf{Advantages:} Self-synchronizing, no DC component, excellent for Ethernet.\\
\textbf{Disadvantages:} Requires twice the bandwidth of NRZ.

\subsubsection{Differential Manchester}

Similar to Manchester but uses transitions differently:
\begin{itemize}
    \item Always has a mid-bit transition (for clocking)
    \item Binary 0 $\rightarrow$ Transition at the beginning of bit period
    \item Binary 1 $\rightarrow$ No transition at the beginning
\end{itemize}

%------------------------------------------------------------------------------
\subsection{Scrambling Techniques: B8ZS and HDB3}
%------------------------------------------------------------------------------

Scrambling techniques address the synchronization problem of AMI encoding when long sequences of zeros occur.

\subsubsection{B8ZS (Bipolar with 8-Zero Substitution) - North American Standard}

B8ZS replaces 8 consecutive zeros with a special violation pattern:

\textbf{Substitution Rule:}
\[
\text{8 zeros} \rightarrow 000VB0VB
\]

where:
\begin{itemize}
    \item V = Violation (same polarity as last pulse, violates AMI rule)
    \item B = Bipolar (alternating polarity, follows AMI rule)
\end{itemize}

The receiver detects these deliberate violations and restores the original zeros. This maintains synchronization while preserving the error detection capability of bipolar encoding.

\subsubsection{HDB3 (High Density Bipolar 3) - European Standard}

HDB3 substitutes 4 consecutive zeros based on the count of 1s since the last substitution:

\textbf{Substitution Rules:}
\begin{itemize}
    \item Odd number of 1s since last substitution: $0000 \rightarrow 000V$
    \item Even number of 1s since last substitution: $0000 \rightarrow B00V$
\end{itemize}

The additional B pulse ensures that violations can always be detected by maintaining proper polarity counting. HDB3 is used in E-carrier systems (E1, E2, etc.) in Europe.

%------------------------------------------------------------------------------
\subsection{Digital-to-Analog Modulation}
%------------------------------------------------------------------------------

Digital-to-analog modulation converts digital data to analog signals for transmission over analog channels such as telephone lines or wireless media.

\subsubsection{ASK (Amplitude Shift Keying)}

The amplitude of the carrier signal represents the digital data:
\begin{equation}
s(t) = A(t) \cdot \cos(2\pi f_c t)
\end{equation}

where $A(t) = 1$ for binary 1 and $A(t) = 0$ for binary 0.

ASK is simple but susceptible to noise that affects signal amplitude.

\subsubsection{FSK (Frequency Shift Keying)}

The frequency of the carrier represents the data:
\begin{equation}
s(t) = \cos(2\pi f_i t)
\end{equation}

where $f_1$ is used for binary 0 and $f_2$ for binary 1. FSK is more robust against noise than ASK.

\subsubsection{PSK (Phase Shift Keying)}

The phase of the carrier represents the data.

\textbf{BPSK (Binary PSK):}
\begin{equation}
s(t) = \cos(2\pi f_c t + \phi)
\end{equation}

where $\phi = 0°$ for binary 0 and $\phi = 180°$ for binary 1.

\textbf{DPSK (Differential PSK):} Phase change represents the data rather than absolute phase, making it easier to implement without requiring carrier phase recovery.

\subsubsection{QAM (Quadrature Amplitude Modulation)}

QAM combines ASK and PSK to achieve higher data rates:
\begin{equation}
s(t) = I \cdot \cos(2\pi f_c t) + Q \cdot \sin(2\pi f_c t)
\end{equation}

where I and Q are the in-phase and quadrature components representing multiple bits per symbol. 4-QAM (QPSK) uses 2 bits per symbol, 16-QAM uses 4 bits, and 64-QAM uses 6 bits.

%------------------------------------------------------------------------------
\subsection{Analog-to-Digital Conversion and the Sampling Theorem}
%------------------------------------------------------------------------------

\subsubsection{The Nyquist Sampling Theorem}

The foundation of analog-to-digital conversion is the \textbf{Nyquist-Shannon Sampling Theorem}:

\begin{quote}
\textit{A continuous-time signal can be completely represented by its samples if the sampling frequency $f_s$ is at least twice the highest frequency component $f_{max}$ of the signal:}
\end{quote}

\begin{equation}
\boxed{f_s \geq 2 \cdot f_{max}}
\end{equation}

If this condition is violated, \textbf{aliasing} occurs, where high-frequency components appear as lower frequencies in the sampled signal, causing irreversible distortion.

\subsubsection{PCM (Pulse Code Modulation)}

PCM is the standard method for digitizing analog signals and involves three steps:

\begin{enumerate}
    \item \textbf{Sampling}: Sample the analog signal at rate $f_s \geq 2f_{max}$
    \item \textbf{Quantization}: Map continuous amplitude values to discrete levels
    \begin{equation}
        L = 2^n
    \end{equation}
    where $n$ is the number of bits and $L$ is the number of quantization levels.
    \item \textbf{Encoding}: Convert quantized values to binary representation
\end{enumerate}

\textbf{Quantization Signal-to-Noise Ratio:}
\begin{equation}
SNR_{dB} = 6.02n + 1.76
\end{equation}

Each additional bit increases the SNR by approximately 6 dB.

\subsubsection{Delta Modulation}

Delta Modulation is a simpler 1-bit encoding using staircase approximation:
\begin{itemize}
    \item If signal $>$ approximation: output 1, increase approximation by step size $\delta$
    \item If signal $\leq$ approximation: output 0, decrease approximation by step size $\delta$
\end{itemize}

\textbf{Types of Distortion:}
\begin{itemize}
    \item \textbf{Slope Overload}: Step size too small to track rapid signal changes
    \item \textbf{Granular Noise}: Step size too large for slow-varying signals
\end{itemize}

%------------------------------------------------------------------------------
\subsection{Analog-to-Analog Modulation}
%------------------------------------------------------------------------------

\subsubsection{AM (Amplitude Modulation)}

In AM, the amplitude of a high-frequency carrier is varied according to the message signal:
\begin{equation}
s(t) = [1 + m \cdot x(t)] \cdot \cos(2\pi f_c t)
\end{equation}

where:
\begin{itemize}
    \item $m$ = modulation index ($0 < m \leq 1$)
    \item $x(t)$ = normalized message signal ($-1 \leq x(t) \leq 1$)
    \item $f_c$ = carrier frequency
\end{itemize}

\textbf{Bandwidth:} $BW = 2 \cdot f_m$ where $f_m$ is the message bandwidth.

\subsubsection{FM (Frequency Modulation)}

In FM, the frequency of the carrier varies with the message signal:
\begin{equation}
s(t) = \cos\left(2\pi f_c t + 2\pi k_f \int_0^t x(\tau) d\tau\right)
\end{equation}

where $k_f$ is the frequency deviation constant.

\textbf{Carson's Rule for Bandwidth:}
\begin{equation}
BW \approx 2(\Delta f + f_m)
\end{equation}

where $\Delta f$ is the peak frequency deviation.

FM provides better noise immunity than AM at the cost of increased bandwidth.

%==============================================================================
\section{Implementation}
%==============================================================================

\subsection{System Architecture}

The implementation follows a modular object-oriented design:

\begin{lstlisting}[language=Python, caption=Class Structure]
# Encoder Classes
class DigitalToDigitalEncoder:
    ALGORITHMS = ['NRZ-L', 'NRZI', 'Bipolar-AMI', 
                  'Manchester', 'Differential Manchester', 
                  'B8ZS', 'HDB3']
    def encode(data, algorithm) -> (time, signal)

class DigitalToAnalogModulator:
    ALGORITHMS = ['ASK', 'BFSK', 'BPSK', 'DPSK', 'QAM']
    def modulate(data, algorithm) -> (time, signal)

class AnalogToDigitalConverter:
    ALGORITHMS = ['PCM', 'Delta Modulation']
    def convert(time, signal, algorithm) -> (samples, bits, quantized)

class AnalogToAnalogModulator:
    ALGORITHMS = ['AM', 'FM']
    def modulate(time, signal, algorithm) -> (time, modulated)
\end{lstlisting}

\subsection{Project Structure}

\begin{verbatim}
signal-encoding-simulator/
├── app.py                      # Streamlit dashboard
├── requirements.txt            # Dependencies
├── encoders/
│   ├── digital_to_digital.py   # 7 line coding algorithms
│   ├── digital_to_analog.py    # 5 modulation algorithms
│   ├── analog_to_digital.py    # PCM, Delta Modulation
│   └── analog_to_analog.py     # AM, FM
├── visualization/
│   └── plotter.py              # Matplotlib visualization
├── benchmarks/
│   ├── version_a.py            # Original implementation
│   ├── version_b.py            # Google Gemini Pro optimized
│   ├── version_c.py            # OpenAI ChatGPT optimized
│   └── run_benchmark.py        # Benchmark runner
└── report/
    └── blg337e_1.pdf           # This report
\end{verbatim}

\subsection{User Interface}

The simulator uses Streamlit to provide an interactive web-based dashboard with:
\begin{itemize}
    \item Mode selection (4 transmission types)
    \item Algorithm selection within each mode
    \item Adjustable parameters (carrier frequency, sample rate, etc.)
    \item Real-time waveform visualization
    \item Encode/Decode verification with match indicators
\end{itemize}

%==============================================================================
\section{AI-Based Optimization and Benchmarking}
%==============================================================================

As required by the assignment, we used \textbf{two different AI tools} to optimize our original implementation:

\begin{itemize}
    \item \textbf{Google Gemini Pro} - For runtime optimization (Version B)
    \item \textbf{OpenAI ChatGPT} - For memory and readability optimization (Version C)
\end{itemize}

\subsection{Optimization Strategies}

Three versions of the core algorithms were developed:

\subsubsection{Version A: Original Implementation}
\begin{itemize}
    \item Straightforward Python implementation using loops
    \item Clear, readable code following the algorithm definitions
    \item Serves as the baseline for comparison
\end{itemize}

\subsubsection{Version B: Google Gemini Pro - Runtime Optimized}

We provided the original code to \textbf{Google Gemini Pro} with the prompt: \textit{``Optimize this code for runtime performance using NumPy vectorization.''}

The AI suggested the following optimizations:
\begin{itemize}
    \item NumPy vectorization replacing Python loops
    \item Use of \texttt{np.where()}, \texttt{np.repeat()}, broadcasting
    \item Pre-computed constants outside loops
    \item Minimized function call overhead
\end{itemize}

\begin{lstlisting}[language=Python, caption=Gemini Pro Optimization Example]
# Original (Version A)
levels = []
for bit in bits:
    level = -1 if bit == 1 else 1
    levels.extend([level, level])

# Gemini Pro Optimized (Version B)
bits_array = np.array(bits)
levels = np.where(bits_array == 1, -1, 1)
signal = np.repeat(levels, samples_per_bit)
\end{lstlisting}

\subsubsection{Version C: OpenAI ChatGPT - Memory Optimized}

We provided the original code to \textbf{OpenAI ChatGPT} with the prompt: \textit{``Optimize this code for memory efficiency and improve code readability with documentation.''}

The AI suggested the following optimizations:
\begin{itemize}
    \item \texttt{float32} instead of \texttt{float64} (50\% memory reduction)
    \item Avoided intermediate array creation
    \item In-place operations where possible
    \item Comprehensive documentation using dataclasses
\end{itemize}

\begin{lstlisting}[language=Python, caption=ChatGPT Optimization Example]
# ChatGPT Optimized (Version C)
@dataclass
class EncodingResult:
    """Result container for encoding operations."""
    time: np.ndarray
    signal: np.ndarray

def nrz_l_encode_v3(bits, samples_per_bit=100):
    # Use float32 instead of float64 (50% less memory)
    signal = np.empty(total_samples, dtype=np.float32)
    time = np.linspace(0, n_bits, total_samples, 
                       dtype=np.float32)
    return EncodingResult(time=time, signal=signal)
\end{lstlisting}

\subsection{Benchmark Results}

Benchmarks were conducted using Python's \texttt{timeit} module for execution time and \texttt{tracemalloc} for memory profiling.

\begin{table}[H]
\centering
\caption{Execution Time Comparison (milliseconds)}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Data Size} & \textbf{Version A} & \textbf{Version B} & \textbf{Version C} & \textbf{C vs A} \\
 & (Original) & (Gemini Pro) & (ChatGPT) & \\
\midrule
100 samples   & 0.745  & 0.632  & 0.319  & -57.2\% \\
500 samples   & 1.882  & 2.203  & 1.318  & -30.0\% \\
1000 samples  & 3.614  & 4.413  & 2.556  & -29.3\% \\
5000 samples  & 18.645 & 22.168 & 18.185 & -2.5\% \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Memory Usage Comparison (kilobytes)}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Data Size} & \textbf{Version A} & \textbf{Version B} & \textbf{Version C} & \textbf{Improvement} \\
 & (Original) & (Gemini Pro) & (ChatGPT) & \\
\midrule
100 samples   & 1,891.90  & 3,504.87  & 1,329.34  & 29.7\% \\
500 samples   & 9,396.13  & 17,257.99 & 6,641.84  & 29.3\% \\
1000 samples  & 18,790.66 & 34,449.40 & 13,282.47 & 29.3\% \\
5000 samples  & 93,946.91 & 171,980.65& 66,407.47 & 29.3\% \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis}

\begin{enumerate}
    \item \textbf{Version B (Gemini Pro - Runtime):} While vectorization typically improves performance, in this case the overhead of creating intermediate arrays actually increased execution time for larger datasets. This demonstrates that vectorization is not always beneficial and depends on the specific operation patterns.
    
    \item \textbf{Version C (ChatGPT - Memory):} Consistently achieved approximately \textbf{29\% memory reduction} by using \texttt{float32} arrays instead of \texttt{float64}. This halves the memory requirement for numerical data while maintaining sufficient precision for signal processing visualization.
    
    \item \textbf{AI Tool Comparison:}
    \begin{itemize}
        \item \textbf{Gemini Pro} focused on algorithmic improvements through vectorization
        \item \textbf{ChatGPT} focused on practical optimizations like data type selection and code structure
        \item Both tools provided valid optimization strategies, but for different use cases
    \end{itemize}
    
    \item \textbf{Trade-offs:} The best choice depends on the use case:
    \begin{itemize}
        \item For memory-constrained environments: Version C (ChatGPT)
        \item For small datasets requiring speed: Version B (Gemini Pro)
        \item For rapid prototyping and maintainability: Version A (Original)
    \end{itemize}
\end{enumerate}

%==============================================================================
\section{Conclusions}
%==============================================================================

This project successfully implemented a comprehensive signal encoding and modulation simulator covering:

\begin{enumerate}
    \item \textbf{16 Algorithms}: 7 line coding (NRZ-L, NRZI, AMI, Manchester, Diff. Manchester, B8ZS, HDB3), 5 digital modulation (ASK, BFSK, BPSK, DPSK, QAM), 2 digitization (PCM, DM), and 2 analog modulation (AM, FM) techniques.
    
    \item \textbf{Interactive Web Interface}: A Streamlit-based dashboard allowing users to select transmission modes, algorithms, and parameters while visualizing the encoding/modulation process in real-time.
    
    \item \textbf{AI-Assisted Optimization}: Used two different AI tools (Google Gemini Pro and OpenAI ChatGPT) to create optimized versions with measurable performance differences.
    
    \item \textbf{Key Technical Insights}:
    \begin{itemize}
        \item The Nyquist Sampling Theorem ($f_s \geq 2f_{max}$) is fundamental to avoiding aliasing in A/D conversion
        \item Scrambling techniques (B8ZS/HDB3) solve synchronization problems while maintaining error detection
        \item Memory optimization using \texttt{float32} provides consistent 29\% memory savings
        \item Different AI tools suggest different optimization strategies based on their training
    \end{itemize}
\end{enumerate}

The simulator is publicly accessible at:

\url{https://signal-encoding-simulator-yuqjysbpdtyaloro8tp4bb.streamlit.app/}
\newpage
%==============================================================================
\section*{References}
%==============================================================================

\begin{enumerate}
    \item Stallings, W. (2014). \textit{Data and Computer Communications} (10th ed.). Pearson.
    \item Forouzan, B. A. (2013). \textit{Data Communications and Networking} (5th ed.). McGraw-Hill.
    \item IEEE 802.3 Standard for Ethernet.
    \item ITU-T G.703 - Physical/Electrical Characteristics of Hierarchical Digital Interfaces.
    \item Nyquist, H. (1928). ``Certain Topics in Telegraph Transmission Theory.'' \textit{Transactions of the AIEE}, 47(2), 617-644.
\end{enumerate}
\newpage
%==============================================================================
\appendix
\section{Running the Simulator}
%==============================================================================

\begin{lstlisting}[language=bash, caption=Installation and Running]
# Clone the repository
git clone https://github.com/nonamexishere/signal-encoding-simulator.git
cd signal-encoding-simulator

# Install dependencies
pip install -r requirements.txt

# Run the Streamlit dashboard
streamlit run app.py

# Run benchmarks
python benchmarks/run_benchmark.py
\end{lstlisting}

\end{document}
